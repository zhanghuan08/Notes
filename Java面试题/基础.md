# 面试题

## 一、Java 基础

**1.JVM、JRE和JDK的关系？**

> ​		**JVM**
> ​		**Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。**
>
> ​		**JRE**
> ​		**Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包**
>
> **如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。**
>
> ​		**JDK**
> ​		**Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等**

**2.== 和 equals 的区别是什么？**

> ​		== :
>
> ​		它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。
>
> ​		(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)
>
> ​		**equals() :** 
>
> ​		它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
>
> ​		情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
>
> ​		情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

**3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？**

> 

**4.final 在 java 中有什么作用？**

> ​	

**5.java 中的 Math.round(-1.5) 等于多少？**

>

**6.String 属于基础的数据类型吗？**

>

**7.java 中操作字符串都有哪些类？它们之间有什么区别？**

>

**8.String str="i"与 String str=new String(“i”)一样吗？**

>

**9.如何将字符串反转？**

>

**10.String 类的常用方法都有那些？**

>

**11.抽象类必须要有抽象方法吗？**

>

**12.普通类和抽象类有哪些区别？**

>

**13.抽象类能使用 final 修饰吗？**

>

**14.接口和抽象类有什么区别？**

>

**15.java 中 IO 流分为几种？**

>

**16.BIO、NIO、AIO 有什么区别？**

>

**17.Files的常用方法都有哪些？**

>

## **二、容器**

**18.java 容器都有哪些？**

>

**19.Collection 和 Collections 有什么区别？**

**20.List、Set、Map 之间的区别是什么？**

**21.HashMap 和 Hashtable 有什么区别？**

**22.如何决定使用 HashMap 还是 TreeMap？**

**23.说一下 HashMap 的实现原理？**

**24.说一下 HashSet 的实现原理？**

**25.ArrayList 和 LinkedList 的区别是什么？**

**26.如何实现数组和 List 之间的转换？**

**27.ArrayList 和 Vector 的区别是什么？**

**28.Array 和 ArrayList 有何区别？**

**29.在 Queue 中 poll()和 remove()有什么区别？**

**30.哪些集合类是线程安全的？**

**31.迭代器 Iterator 是什么？**

**32.Iterator 怎么使用？有什么特点？**

**33.Iterator 和 ListIterator 有什么区别？**

**34.怎么确保一个集合不能被修改？**

## **三、多线程**

**35.并行和并发有什么区别？**

**36.线程和进程的区别？**

**37.守护线程是什么？**

**38.创建线程有哪几种方式？**

**39.说一下 runnable 和 callable 有什么区别？**

**40.线程有哪些状态？**

**41.sleep() 和 wait() 有什么区别？**

>区别1：使用限制
>
>​		使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。
>
>​		而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。而且 wait 还需要额外的方法 notify/ notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。
>
>区别2：使用场景
>
>​		sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。
>
>区别3：所属类
>
>​		sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。
>
>区别4：释放锁
>
>```java
>Object lock = new Object();
>synchronized (lock) {
>try {
>   lock.wait(3000L);
>   Thread.sleep(2000L);
>} catch (InterruptedException e) {
>   e.printStackTrace();
>}
>}
>```
>
>如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。
>
>区别5：线程切换
>
>​		sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。

**42.notify()和 notifyAll()有什么区别？**

**43.线程的 run()和 start()有什么区别？**

**44.创建线程池有哪几种方式？**

**45.线程池都有哪些状态？**

**46.线程池中 submit()和 execute()方法有什么区别？**

**47.在 java 程序中怎么保证多线程的运行安全？**

**48.多线程锁的升级原理是什么？**

**49.什么是死锁？**

**50.怎么防止死锁？**

**51.ThreadLocal 是什么？有哪些使用场景？**

**52.说一下 synchronized 底层实现原理？**

**53.synchronized 和 volatile 的区别是什么？**

**54.synchronized 和 Lock 有什么区别？**

>1、Synchronized是关键字，内置语言实现，Lock是接口。
>
>2、Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。
>
>3、Lock是可以中断锁，Synchronized是非中断锁，必须等待线程执行完成释放锁。
>
>4、Lock可以使用读锁提高多线程读效率。

**55.synchronized 和 ReentrantLock 区别是什么？**

**56.说一下 atomic 的原理？**

## **四、反射**

**57.什么是反射？**

>### 反射
>
>**简单介绍：**
>
>​		JAVA反射机制是在**运行状态中**，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。

**59.动态代理是什么？有哪些应用？**

**60.怎么实现动态代理？**

## **五、对象拷贝**

**61.为什么要使用克隆？**

**62.如何实现对象克隆？**

**63.深拷贝和浅拷贝区别是什么？**

## **六、Java Web**

**64.jsp 和 servlet 有什么区别？**

**65.jsp 有哪些内置对象？作用分别是什么？**

**66.说一下 jsp 的 4 种作用域？**

**67.session 和 cookie 有什么区别？**

**68.说一下 session 的工作原理？**

**69.如果客户端禁止 cookie 能实现 session 还能用吗？**

**70.spring mvc 和 struts 的区别是什么？**

**71.如何避免 sql 注入？**

**72.什么是 XSS 攻击，如何避免？**

**73.什么是 CSRF 攻击，如何避免？**

## **七、异常**

**74.throw 和 throws 的区别？**

**75.final、finally、finalize 有什么区别？**

**76.try-catch-finally 中哪个部分可以省略？**

**77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？**

**78.常见的异常类有哪些？**

## **八、网络**

**79.http 响应码 301 和 302 代表的是什么？有什么区别？**

**80.forward 和 redirect 的区别？**



**81.简述 tcp 和 udp的区别？**

**82.tcp 为什么要三次握手，两次不行吗？为什么？**

**83.说一下 tcp 粘包是怎么产生的？**

**84.OSI 的七层模型都有哪些？**

**85.get 和 post 请求有哪些区别？**

**86.如何实现跨域？**

**87.说一下 JSONP 实现原理？**

## **九、设计模式**

**88.说一下你熟悉的设计模式？**

**89.简单工厂和抽象工厂有什么区别？**

## **十、Spring/Spring MVC**

**90.为什么要使用 spring？**

**91.解释一下什么是 aop？**

**92.解释一下什么是 ioc？**

**93.spring 有哪些主要模块？**

**94.spring 常用的注入方式有哪些？**

**95.spring 中的 bean 是线程安全的吗？**

**96.spring 支持几种 bean 的作用域？**

**97.spring 自动装配 bean 有哪些方式？**

**98.spring 事务实现方式有哪些？**

**99.说一下 spring 的事务隔离？**

**100.说一下 spring mvc 运行流程？**

**101.spring mvc 有哪些组件？**

**102.@RequestMapping 的作用是什么？**

**103.@Autowired 的作用是什么？**

## **十一、Spring Boot/Spring Cloud**

**104.什么是 spring boot？**

**105.为什么要用 spring boot？**

**106.spring boot 核心配置文件是什么？**

**107.spring boot 配置文件有哪几种类型？它们有什么区别？**

**108.spring boot 有哪些方式可以实现热部署？**

**109.jpa 和 hibernate 有什么区别？**

**110.什么是 spring cloud？**

**111.spring cloud 断路器的作用是什么？**

**112.spring cloud 的核心组件有哪些？**

## **十二、Hibernate**

**113.为什么要使用 hibernate？**

**114.什么是 ORM 框架？**

**115.hibernate 中如何在控制台查看打印的 sql 语句？**

**116.hibernate 有几种查询方式？**

**117.hibernate 实体类可以被定义为 final 吗？**

**118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？**

**119.hibernate 是如何工作的？**

**120.get()和 load()的区别？**

**121.说一下 hibernate 的缓存机制？**

**122.hibernate 对象有哪些状态？**

**123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？**

**124.hibernate 实体类必须要有无参构造函数吗？为什么？**

## **十三、Mybatis**

**125.mybatis 中 #{}和 ${}的区别是什么？**

**126.mybatis 有几种分页方式？**

**127.RowBounds 是一次性查询全部结果吗？为什么？**

**128.mybatis 逻辑分页和物理分页的区别是什么？**

**129.mybatis 是否支持延迟加载？延迟加载的原理是什么？**

**130.说一下 mybatis 的一级缓存和二级缓存？**

**131.mybatis 和 hibernate 的区别有哪些？**

**132.mybatis 有哪些执行器（Executor）？**

**133.mybatis 分页插件的实现原理是什么？**

**134.mybatis 如何编写一个自定义插件？**

## **十四、RabbitMQ**

**135.rabbitmq 的使用场景有哪些？**

**136.rabbitmq 有哪些重要的角色？**

**137.rabbitmq 有哪些重要的组件？**

**138.rabbitmq 中 vhost 的作用是什么？**

**139.rabbitmq 的消息是怎么发送的？**

**140.rabbitmq 怎么保证消息的稳定性？**

**141.rabbitmq 怎么避免消息丢失？**

**142.要保证消息持久化成功的条件有哪些？**

**143.rabbitmq 持久化有什么缺点？**

**144.rabbitmq 有几种广播类型？**

**145.rabbitmq 怎么实现延迟消息队列？**

**146.rabbitmq 集群有什么用？**

**147.rabbitmq 节点的类型有哪些？**

**148.rabbitmq 集群搭建需要注意哪些问题？**

**149.rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？**

**150.rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？**

**151.rabbitmq 对集群节点停止顺序有要求吗？**

## **十五、Kafka**

**152.kafka 可以脱离 zookeeper 单独使用吗？为什么？**

**153.kafka 有几种数据保留的策略？**

**154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？**

**155.什么情况会导致 kafka 运行变慢？**

**156.使用 kafka 集群需要注意什么？**

## **十六、Zookeeper**

**157.zookeeper 是什么？**

**158.zookeeper 都有哪些功能？**

**159.zookeeper 有几种部署模式？**

**160.zookeeper 怎么保证主从节点的状态同步？**

**161.集群中为什么要有主节点？**

**162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？**

**163.说一下 zookeeper 的通知机制？**

## 十七、MySql

**164.数据库的三范式是什么？**

**165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？**

**166.如何获取当前数据库版本？**

**167.说一下 ACID 是什么？**

**168.char 和 varchar 的区别是什么？**

**169.float 和 double 的区别是什么？**

**170.mysql 的内连接、左连接、右连接有什么区别？**

**171.mysql 索引是怎么实现的？**

**172.怎么验证 mysql 的索引是否满足需求？**

**173.说一下数据库的事务隔离？**

**174.说一下 mysql 常用的引擎？**

**175.说一下 mysql 的行锁和表锁？**

**176.说一下乐观锁和悲观锁？**

**177.mysql 问题排查都有哪些手段？**

**178.如何做 mysql 的性能优化？**

## 十八、Redis

**179.redis 是什么？都有哪些使用场景？**

**180.redis 有哪些功能？**

**181.redis 和 memecache 有什么区别？**

**182.redis 为什么是单线程的？**

**183.什么是缓存穿透？怎么解决？**

**184.redis 支持的数据类型有哪些？**

**185.redis 支持的 java 客户端都有哪些？**

**186.jedis 和 redisson 有哪些区别？**

**187.怎么保证缓存和数据库数据的一致性？**

**188.redis 持久化有几种方式？**

**189.redis 怎么实现分布式锁？**

**190.redis 分布式锁有什么缺陷？**

**191.redis 如何做内存优化？**

**192.redis 淘汰策略有哪些？**

**193.redis 常见的性能问题有哪些？该如何解决？**

## 十九、JVM

**194.说一下 jvm 的主要组成部分？及其作用？**

**195.说一下 jvm 运行时数据区？**

**196.说一下堆栈的区别？**

**197.队列和栈是什么？有什么区别？**

**198.什么是双亲委派模型？**

**199.说一下类加载的执行过程？**

**200.怎么判断对象是否可以被回收？**

**201.java 中都有哪些引用类型？**

**202.说一下 jvm 有哪些垃圾回收算法？**

**203.说一下 jvm 有哪些垃圾回收器？**

**204.详细介绍一下 CMS 垃圾回收器？**

**205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？**

**206.简述分代垃圾回收器是怎么工作的？**

**207.说一下 jvm 调优的工具？**

**208.常用的 jvm 调优的参数都有哪些？**



## 实习一面：

**1.java有哪些数据类型，分别是什么？**

>四类八种：整数型：byte、short、int、long
>
>​						浮点型：float、double
>
>​						字符型：char
>
>​						布尔型：boolean

**2.float f =3.4;正确吗？**

> 不正确，没有进行类型强制转换；float f = (float)3.4;

**3.jsp有哪些作用域，作用分别是什么？**

>

**4.String 和StringBuffer 的区别？**

>

**5.抽象类和接口的区别。**

>

**6.SpringMVC的常用注解有哪些？作用是什么？**

>

**7.拦截器是什么？拦截器和过滤器有什么区别？**

>

**8.String的优点是什么？**

>

**9.依赖注入是什么？作用是什么？**



## 实习二面：

**10.Java的容器有哪些，哪些是同步容器，哪些是并发容器？**

>解答：[Java容器有哪些？哪些是同步容器,哪些是并发容器？_u013030086的博客-CSDN博客](https://blog.csdn.net/u013030086/article/details/84791668)
>
>**Collection**
>
>​		List
>
>​		Set
>
>**Map**
>
>同步容器:
>
>- Vector
>- Stack
>- HashTable
>- Collections.synchronized方法生成
>
>并发容器
>
>- ConcurrentHashMap：线程安全的HashMap的实现
>- CopyOnWriteArrayList：线程安全且在读操作时无锁的ArrayList
>- CopyOnWriteArraySet：基于CopyOnWriteArrayList，不添加重复元素
>- ArrayBlockingQueue：基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制
>- LinkedBlockingQueue：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于ArrayBlockingQueue



**11.Java的反射机制和注解原理**

>### 反射
>
>**简单介绍：**
>
>JAVA反射机制是在**运行状态中**，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。

**12.http和https的区别**

>1、HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。
>
>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。
>
>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
>
>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

**13.sleep和wait的区别？**

>区别1：使用限制
>
>​		使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。
>
>​		而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。而且 wait 还需要额外的方法 notify/ notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。
>
>区别2：使用场景
>
>​		sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。
>
>区别3：所属类
>
>​		sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。
>
>区别4：释放锁
>
>```java
>Object lock = new Object();
>synchronized (lock) {
>    try {
>        lock.wait(3000L);
>        Thread.sleep(2000L);
>    } catch (InterruptedException e) {
>        e.printStackTrace();
>    }
>}
>```
>
>如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。
>
>区别5：线程切换
>
>​		sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。

**14.解释volatile关键字的作用**

>​		保证了变量的可见性（visibility）。被volatile关键字修饰的变量，如果值发生了变更，其他线程立马可见，避免出现脏读的现象。

**15.Cas是什么意思，如何实现的？**

>​		cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。

**16.JUNIT5和JUNIT4的区别？**

>Junit 4需要Java 5或更高版本。
>
>Junit 5需要Java 8或更高版本。

**17.类的加载机制**

> ​		JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。其中加载、检验、准备、初始化和卸载这个五个阶段的顺序是固定的，而解析则未必。为了支持动态绑定，解析这个过程可以发生在初始化阶段之后。
>
> ### 加载：
>
> 加载过程主要完成三件事情：
>
> 1. 通过类的全限定名来获取定义此类的二进制字节流
> 2. 将这个类字节流代表的静态存储结构转为方法区的运行时数据结构
> 3. 在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。
>
> 这个过程主要就是类加载器完成。
>
> ### 校验：
>
> 此阶段主要确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。
>
> 1. 文件格式验证：基于字节流验证。
> 2. 元数据验证：基于**方法区**的存储结构验证。
> 3. 字节码验证：基于方法区的存储结构验证。
> 4. 符号引用验证：基于方法区的存储结构验证。

**18.Synchronized和Lock的区别？**

>1、Synchronized是关键字，内置语言实现，Lock是接口。
>
>2、Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。
>
>3、Lock是可以中断锁，Synchronized是非中断锁，必须等待线程执行完成释放锁。
>
>4、Lock可以使用读锁提高多线程读效率。
>
>
>
>**两种锁的底层实现**
>
>​		Synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。
>
>​		Lock：底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。

**19.Integer和int的区别？**

>1、Integer是int的包装类，int则是java的一种基本数据类型 
>2、Integer变量必须实例化后才能使用，而int变量不需要 
>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 
>4、Integer的默认值是null，int的默认值是0

**20.HashSet的原理**

>HashSet底层由HashMap实现，初始化时，实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 
>
>选择0.75是：提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小
>HashSet的值存放于HashMap的key上
>HashMap的value统一为PRESENT

**21.简述一下事务的隔离级别**

>1、事务的基本要素（ACID）：
>
>​		1.1、原子性(Atomicity)：
>
>​				事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
>
>​		1.2、一致性(Consistency)：
>
>​				事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
>
>​		1.3、隔离性(Isolation)
>
>​				同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
>
>​		1.4、持久性(Durability):
>
>​				事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。
>
>2、事务的并发问题
>
>​		脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据**
>
>​		不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。**
>
>　　幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
>
>3、事务隔离级别
>
>​		mysql默认的事务隔离级别为repeatable-read
>
>|         事务隔离级别         | 脏读 | 不可重复读 | 幻读 |
>| :--------------------------: | :--: | :--------: | :--: |
>| 读未提交（read-uncommitted） |  是  |     是     |  是  |
>| 不可重复读（read-committed） |  否  |     是     |  是  |
>| 可重复读（repeatable-read）  |  否  |     否     |  是  |
>|    串行化（serializable）    |  否  |     否     |  否  |

**22.Myisam引擎和innodb引擎的区别**

>1、innodb支持事务，Myisam不支持；
>
>2、InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；
>
>3、InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大，MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的；
>
>4、InnoDB不保存表的具体行数，执行select count(\*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；
>
>5、Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了；
>
>6、MyISAM表格可以被压缩后进行查询操作；
>
>7、InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁；
>
>8、InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有；
>
>9、Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI
>
>​		Innodb：frm是表定义文件，ibd是数据文件
>
>​		Myisam：frm是表定义文件，myd是数据文件，myi是索引文件

**23.MySQL常见索引有哪些？**

>一. 四种索引(主键索引/普通索引/全文索引/唯一索引)

**24.常见的sql优化**

>1、通过变量的方式来设置参数
>
>2、不要使用select  *
>
>3、谨慎使用模糊查询
>
>4、不要使用列号
>
>5、优先使用UNION ALL，避免使用UNION
>
>6、在where语句或者order by语句中避免对索引字段进行计算操作
>
>7、使用not exist代替not in
>
>8、复杂操作可以考虑适当拆成几步

**25.ArrayList与linkedList有什么区别？**

>