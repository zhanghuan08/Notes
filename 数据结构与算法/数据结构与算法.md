# 数据结构与算法

## 一、数据结构概述

### 1. 什么是数据结构

​		数据结构是相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。

###  1.1 数据的存储结构

​		数据的存储结构分为`顺序存储`和`链式存储`两种结构

#### 1.1.1顺序存储结构

![image-20210122145911407](http://image.codehuan.cn/image/image-20210122145911407.png)

#### 1.1.2链式存储结构

![image-20210122150146787](http://image.codehuan.cn/image/image-20210122150146787.png)

### 1.2 数据的逻辑结构

​		数据的逻辑结构有`集合结构`、`线性结构`、`树形结构`和`图形结构`4种结构。

#### 1.2.1 集合结构

​		集合结构中的数据元素属于同一个集合，他们之间是并列的关系，除此之外没有其他关系。

<img src="http://image.codehuan.cn/image/image-20210122150953618.png" alt="image-20210122150953618" style="zoom:25%;" />

#### 1.2.2 线性结构

​		线性结构中的元素存在一对一的相互关系。

|  ID  | Name |
| :--: | :--: |
|  1   | 张三 |
|  2   | 李四 |
|  3   | 王五 |

#### 1.2.3 树形结构

​		   树形结构中的元素存在一对多的相互关系。

<img src="http://image.codehuan.cn/image/image-20210122151311530.png" alt="image-20210122151311530" style="zoom: 50%;" />

#### 1.2.4 图形结构

​		 图形结构中的元素存在多对多的相互关系。

![image-20210122151450591](http://image.codehuan.cn/image/image-20210122151450591.png)

### 1.3 常见的数据结构

- **栈（Stack）：**栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。
- **队列（Queue）：**队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。
- **数组（Array）：**数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。
- **链表（Linked List）：**链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。
- **树（Tree）：**树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。
- **图（Graph）：**图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。
- **堆（Heap）：**堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。
- **散列表（Hash table）：**散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。

## 二、算法概述

### 1.1 算法的定义

​		算法是指对特定问题求解步骤的完整描述，是一系列解决问题的清晰指令。

### 1.2 算法的特效

- 输入项（Input）
- 输出项（Output）
- 有穷性（Finiteness）
- 确切性（Definiteness）
- 可行性（Effectiveness）

### 1.3 算法的基本要求

- 正确性：没有语法错误等。
- 可读性：设计出来的算法要便于阅读、理解和交流。
- 健壮性：指软件对于规范要求以外的输入情况的处理能力。
- 时间复杂度：即算法程序耗费的时间多少。
- 空间复杂度：即算法程序占用的空间多少。

## 三、线性结构

### 1.1 数组

#### 1.1.1 数组的基本使用

#### 1.1.2 面向对象的数组



#### 1.1.3 查找算法

##### 1.1.3.1 线性查找

<img src="http://image.codehuan.cn/image/image-20210124151215964.png" alt="image-20210124151215964" style="zoom: 80%;" />

##### 1.1.3.2 二分法查找

使用二分法查找时该数组必须是==有序排列==的

### 1.2 栈

<img src="http://image.codehuan.cn/image/image-20210124164107108.png" alt="image-20210124164107108" style="zoom: 80%;" />

### 1.3 单链表

链表是有序的列表，但是它在内存中的存储如下

<img src="http://image.codehuan.cn/image/image-20210126175709095.png" alt="image-20210126175709095" style="zoom: 60%;" />

<img src="http://image.codehuan.cn/image/image-20210125190036879.png" alt="image-20210125190036879" style="zoom: 80%;" />

小结：

- 链表是以节点的方式来存储的
- 每一个节点包含data域，next域：指向下一个节点
- 链表分带头节点的链表和没有头节点的链表，

### 1.4 循环链表



### 1.5 双链表



### 1.6 递归

## 四、排序算法

### 1.1 交换排序

#### 1.1.1 冒泡排序

#### 1.1.2 快速排序

### 1.2 插入排序

#### 1.2.1 直接插入排序

#### 1.2.2 希尔排序

### 1.3 选择排序

#### 1.3.1 简单选择排序

#### 1.3.2 堆排序

### 1.4 归并排序

### 1.5 基数排序

## 五、树结构

### 1.1 树结构概述

### 1.2 二叉树

#### 概念：

> 1. 每个节点**最多只能有两个子节点**的一种形式称为二叉树。
> 2. 二叉树的子节点分为左节点和右节点。
> 3. 如果该二叉树的所有叶子节点都在最后一层，并且结点总数=2^n^-1，n为层数，则我们称为满二叉树
> 4. 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。

二叉树示意图

<img src="http://image.codehuan.cn/image/image-20210207164415296.png" alt="image-20210207164415296" style="zoom:50%;" />

满二叉树：

![image-20210207164806755](http://image.codehuan.cn/image/image-20210207164806755.png)

完全二叉树：

![完全二叉树](http://image.codehuan.cn/image/image-20210207164912340.png)

#### 二叉树遍历

前序遍历：先输出父节点，再遍历左子树和右子树。

中序遍历：先遍历左子树，再输出父节点，最后遍历右子树。

后序遍历：先遍历左子树，再遍历右子树，最后输出父节点。

**小结**：看输出父节点的顺序，就确定是前序，中序还是后续

**分析二叉树的前序，中序，后序的遍历步骤：**

1. 创建一棵二叉树
2. 前序遍历
   1. 先输出当前节点（初始的时候是root节点）
   2. 如果左子节点不为空，则递归继续前序遍历
   3. 如果右子节点不为空，则递归继续前序遍历
3. 中序遍历
   1. 如果当前节点的左子节点不为空，则递中序遍历
   2. 输出当前节点
   3. 如果当前节点的右子节点不为空，则递中序遍历
4. 后序遍历
   1. 如果当前节点的左子节点不为空，则递后序遍历
   2. 如果当前节点的右子节点不为空，则递后序遍历
   3. 输出当前节点

**练习1：**

使用前序，中序，后序对下面的二叉树进行遍历

<img src="http://image.codehuan.cn/image/image-20210207163845812.png" alt="image-20210207163845812" style="zoom:50%;" />

```java
package com.codehuan.binarytree;

/**
 * @author ZhangHuan created on 2021/2/7
 */
public class BinaryTreeDemo {
    public static void main(String[] args) {
        // 创建一棵二叉树
        BinaryTree binaryTree = new BinaryTree();
        // 创建需要的节点
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");
        // 先手动创建二叉树，之后学习递归的方式创建
        binaryTree.setRoot(root);
        root.setLeftNode(node2);
        root.setRightNode(node3);
        node3.setRightNode(node4);
        // 测试
        System.out.println("前序遍历：");
        binaryTree.preOrder();

        System.out.println("中序遍历：");
        binaryTree.infixOrder();

        System.out.println("后序遍历：");
        binaryTree.postOrder();
    }
}

//定义 BinaryTree 二叉树
class BinaryTree {
    private HeroNode root;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    // 前序遍历
    public void preOrder() {
        if (this.root != null) {
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    // 中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    // 后序遍历
    public void postOrder() {
        if (this.root != null) {
            this.root.postOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
}

//先创建HeroNode节点
class HeroNode {
    private int id;
    private String name;
    /**
     * 默认null
     */
    private HeroNode leftNode;
    /**
     * 默认null
     */
    private HeroNode rightNode;

    public HeroNode(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeftNode() {
        return leftNode;
    }

    public void setLeftNode(HeroNode leftNode) {
        this.leftNode = leftNode;
    }

    public HeroNode getRightNode() {
        return rightNode;
    }

    public void setRightNode(HeroNode rightNode) {
        this.rightNode = rightNode;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }

    // 编写前序遍历的方法
    public void preOrder() {
        //先输出父节点
        System.out.println(this);
        // 递归向左子树前序遍历
        if (this.leftNode != null) {
            this.leftNode.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.rightNode != null) {
            this.rightNode.preOrder();
        }
    }

    // 中序遍历的方法
    public void infixOrder() {
        // 递归向左子树中序遍历
        if (this.leftNode != null) {
            this.leftNode.infixOrder();
        }
        //先输出当前节点 父节点
        System.out.println(this);
        // 递归向右子树中序遍历
        if (this.rightNode != null) {
            this.rightNode.preOrder();
        }
    }

    // 后序遍历的方法
    public void postOrder() {
        // 递归向左子树后序遍历
        if (this.leftNode != null) {
            this.leftNode.postOrder();
        }
        // 递归向右子树后序遍历
        if (this.rightNode != null) {
            this.rightNode.postOrder();
        }
        //先输出当前节点
        System.out.println(this);
    }
}
```

<img src="http://image.codehuan.cn/image/image-20210207164233179.png" alt="image-20210207164233179" style="zoom:50%;" />

​		前上图的3号节点"卢俊"，增加一个左子节点[5,关胜]
使用前序，中序，后序遍历，请写出各自输出的顺序是什么?

**练习2：**

​	使用前序，中序，后序的方式来查询指定的节点。

**分析二叉树的前序，中序，后序的前序查找思路：**

- **前序查找**
  1. 先判断当前的节点id是否等于要查找的
  2. 如果相等，则返回当前节点
  3. 如果不相等，则判断当前节点的左子节点是否为空，如果不为空，则递归前序需查找
  4. 如果左递归前序查找找到节点，则返回，否则继续判断，当前的节点的右子节点是否为空，如果不空，则继续向右递归前序查找。
- **中序查找**
  1. 判断当前节点的左子节点是否为空，如果不为空，则递归中需查找
  2. 如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点，否则继续进行右递归的中序查找
  3. 如果右递归中序查找找到就返回，否则返回null
- **后续查找**
  1. 判断当前节点的左子节点是否为空，如果不为空，则递归后需查找
  2. 如果找到，则返回，如果没有找到，就判断当前节点的右子节点是否为空，如果不为空，则右递归进行后序查找，如果找到，就返回
  3. 和当前节点进行比较，

### 1.3 线索二叉树

### 1.4 赫夫曼树

### 1.5 二叉查找树

### 1.6 AVL树

### 1.7 多路查找树

## 六、哈希表

## 七、图结构

